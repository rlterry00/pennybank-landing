{"version":3,"sources":["../../src/utils/map-pages-to-static-query-hashes.ts"],"names":["mapComponentsToStaticQueryHashes","staticQueryComponents","map","Map","forEach","componentPath","hash","set","mapTemplatesToStaticQueryHashes","reduxState","compilation","components","modules","terminalNodes","globalStaticQueries","Set","getDeps","mod","staticQueryModuleComponentPath","resource","result","getDepsFn","m","hasReasons","isTerminalNode","some","terminalNode","includes","nonTerminalDependents","reasons","filter","r","dependentModule","module","isTerminal","Boolean","uniqDependents","d","identifier","uniqDependent","add","mapOfStaticQueryComponentsToDependants","staticQueryComponentModule","find","dependants","mapOfComponentsToStaticQueryHashes","globalStaticQueryHashes","q","get","push","mapOfTemplatesToStaticQueryHashes","page","staticQueryHashes","has","setOfDependants","staticQueryComponentPath","sort"],"mappings":"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","sourcesContent":["import { uniqBy, List } from \"lodash\"\nimport { IGatsbyState } from \"../redux/types\"\nimport { Stats } from \"webpack\"\n\ninterface ICompilation {\n  modules: IModule[]\n}\n\ninterface IReason extends Omit<Stats.Reason, \"module\"> {\n  module: IModule\n}\n\ninterface IModule extends Omit<Stats.FnModules, \"identifier\" | \"reasons\"> {\n  hasReasons: () => boolean\n  resource?: string\n  identifier: () => string\n  reasons: IReason[]\n}\n\nconst mapComponentsToStaticQueryHashes = (\n  staticQueryComponents: IGatsbyState[\"staticQueryComponents\"]\n): Map<string, string> => {\n  const map = new Map()\n\n  staticQueryComponents.forEach(({ componentPath, hash }) => {\n    map.set(componentPath, hash)\n  })\n\n  return map\n}\n\n/* This function takes the current Redux state and a compilation\n * object from webpack and returns a map of unique templates\n * to static queries included in each (as hashes).\n *\n * This isn't super straightforward because templates may include\n * deep component trees with static queries present at any depth.\n * This is why it is necessary to map templates to all their (user land and node_modules)\n * dependencies first and then map those dependencies to known static queries.\n *\n * Also, Gatsby makes it possible to wrap an entire site or page with a layout\n * or other component(s) via the wrapRootElement and wrapPageElement APIs. These must\n * also be handled when computing static queries for a page.\n *\n * Let's go through the implementation step by step.\n */\nexport function mapTemplatesToStaticQueryHashes(\n  reduxState: IGatsbyState,\n  compilation: ICompilation\n): Map<string, Array<number>> {\n  /* The `staticQueryComponents` slice of state is useful because\n   * it is a pre extracted collection of all static queries found in a Gatsby site.\n   * This lets us traverse upwards from those to templates that\n   * may contain components that contain them.\n   * Note that this upward traversal is much shallower (and hence more performant)\n   * than an equivalent downward one from an entry point.\n   */\n  const { components, staticQueryComponents } = reduxState\n  const { modules } = compilation\n\n  /* When we traverse upwards, we need to know where to stop. We'll call these terminal nodes.\n   * `async-requires.js` is the entry point for every page, while `api-runner-browser-plugins.js`\n   * is the one for `gatsby-browser` (where one would use wrapRootElement or wrapPageElement APIs)\n   */\n  const terminalNodes = [\n    `.cache/api-runner-browser-plugins.js`,\n    `.cache/async-requires.js`,\n  ]\n\n  /* We call the queries included above a page (via wrapRootElement or wrapPageElement APIs)\n   * global queries. For now, we include these in every single page for simplicity. Overhead\n   * here is not much since we are storing hashes (that reference separate result files)\n   * as opposed to inlining results. We may move these to app-data perhaps in the future.\n   */\n  const globalStaticQueries = new Set<string>()\n\n  /* This function takes a webpack module corresponding\n   * to the file containing a static query and returns\n   * a Set of strings, each an absolute path of a dependent\n   * of this module\n   */\n  const getDeps = (mod: IModule): Set<string> => {\n    const staticQueryModuleComponentPath = mod.resource\n    const result = new Set<string>()\n\n    // This is the body of the recursively called function\n    const getDepsFn = (m: IModule): Set<string> => {\n      // Reasons in webpack are literally reasons of why this module was included in the tree\n      const hasReasons = m.hasReasons()\n\n      // Is this node one of our known terminal nodes? See explanation above\n      const isTerminalNode = terminalNodes.some(terminalNode =>\n        m?.resource?.includes(terminalNode)\n      )\n\n      // Exit if we don't have any reasons or we have reached a possible terminal node\n      if (!hasReasons || isTerminalNode) {\n        return result\n      }\n\n      // These are non terminal dependents and hence modules that need\n      // further upward traversal\n      const nonTerminalDependents: List<IModule> = m.reasons\n        .filter(r => {\n          const dependentModule = r.module\n          const isTerminal = terminalNodes.some(terminalNode =>\n            dependentModule?.resource?.includes(terminalNode)\n          )\n          return !isTerminal\n        })\n        .map(r => r.module)\n        .filter(Boolean)\n\n      const uniqDependents = uniqBy(nonTerminalDependents, d => d?.identifier())\n\n      for (const uniqDependent of uniqDependents) {\n        if (uniqDependent.resource) {\n          result.add(uniqDependent.resource)\n        }\n\n        if (\n          uniqDependent?.resource?.includes(`gatsby-browser.js`) &&\n          staticQueryModuleComponentPath\n        ) {\n          globalStaticQueries.add(staticQueryModuleComponentPath)\n        }\n        getDepsFn(uniqDependent)\n      }\n\n      return result\n    }\n\n    return getDepsFn(mod)\n  }\n\n  const mapOfStaticQueryComponentsToDependants = new Map()\n\n  // For every known static query, we get its dependents.\n  staticQueryComponents.forEach(({ componentPath }) => {\n    const staticQueryComponentModule = modules.find(\n      m => m.resource === componentPath\n    )\n\n    const dependants = staticQueryComponentModule\n      ? getDeps(staticQueryComponentModule)\n      : new Set()\n\n    mapOfStaticQueryComponentsToDependants.set(componentPath, dependants)\n  })\n\n  const mapOfComponentsToStaticQueryHashes = mapComponentsToStaticQueryHashes(\n    staticQueryComponents\n  )\n\n  const globalStaticQueryHashes: string[] = []\n\n  globalStaticQueries.forEach(q => {\n    const hash = mapOfComponentsToStaticQueryHashes.get(q)\n    if (hash) {\n      globalStaticQueryHashes.push(hash)\n    }\n  })\n\n  // For every known page, we get queries\n  const mapOfTemplatesToStaticQueryHashes = new Map()\n\n  components.forEach(page => {\n    const staticQueryHashes = [...globalStaticQueryHashes]\n\n    // Does this page contain an inline static query?\n    if (mapOfComponentsToStaticQueryHashes.has(page.componentPath)) {\n      const hash = mapOfComponentsToStaticQueryHashes.get(page.componentPath)\n      if (hash) {\n        staticQueryHashes.push(hash)\n      }\n    }\n\n    // Check dependencies\n    mapOfStaticQueryComponentsToDependants.forEach(\n      (setOfDependants, staticQueryComponentPath) => {\n        if (setOfDependants.has(page.componentPath)) {\n          const hash = mapOfComponentsToStaticQueryHashes.get(\n            staticQueryComponentPath\n          )\n          if (hash) {\n            staticQueryHashes.push(hash)\n          }\n        }\n      }\n    )\n\n    mapOfTemplatesToStaticQueryHashes.set(\n      page.componentPath,\n      staticQueryHashes.sort()\n    )\n  })\n\n  return mapOfTemplatesToStaticQueryHashes\n}\n"],"file":"map-pages-to-static-query-hashes.js"}